#!/usr/bin/env perl

use warnings;
use strict;
use JSON::XS;
use File::Slurp qw/read_file/;
use Time::HiRes qw/sleep gettimeofday tv_interval/;

#################################################
# settings
my $NUM         = 10;
my $REQUESTS    = $ENV{REQUESTS}    || 100;
my $CONCURRENCY = $ENV{CONCURRENCY} || 5;
my $DELAY       = $ENV{DELAY}       || 2;
my $BASEPORT    = 3000;
my $BASEURL     = "http://127.0.0.1:$BASEPORT/thruk";

#################################################
# prepare
cleanup();
my $author = -f '.author' ? 1 : 0;
unlink('.author');
my $results_file = '.rps_results';
my $results = {};
if(-f $results_file) {
    $results = JSON::XS::decode_json(read_file($results_file));
}

#################################################
# run tests
print("+-------------+---------+---------+-----------------+-----------------+-----------------+-----------------+-----------------+-----------------------+-------+\n");
print("| Branch      | Startup | 1st Req | Static HTML     | Tactical CGI    | Status CGI      | JSON CGI        | Business P. CGI | Memory                | Load  |\n");
print("+-------------+---------+---------+-----------------+-----------------+-----------------+-----------------+-----------------+-----------------------+-------+\n");
chomp(my $branch = `git branch --no-color 2>/dev/null | grep ^\*`);
$branch =~ s|^\*\s+||mx;
my $tags = [];
if(scalar @ARGV == 0) {
    $tags = [reverse split(/\n/, `git tag -l | awk -F- '{ print \$1 }' | sort -u | tail -$NUM`)];
    if($branch ne 'master') { unshift @{$tags}, 'master' }
    unshift @{$tags}, $branch;
} else {
    $tags = \@ARGV;
}

#################################################
END {
    cleanup();
    switch_tag($branch);
    `touch .author` if $author;
    print "\n";
}
$SIG{'INT'}  = sub {
    cleanup();
    switch_tag($branch);
    `touch .author` if $author;
    exit;
};

#################################################
# run tests
for my $tag (@{$tags}) {
    $tag =~ s|^\*\s+||gmx;
    if($tag =~ /^v/mx) {
        # get latest sp for this tag
        chomp($tag = `git tag -l 2>/dev/null | grep $tag | tail -n 1`);
    }
    test_tag($tag);
}
print("+-------------+---------+---------+-----------------+-----------------+-----------------+-----------------+-----------------+-----------------------+-------+\n");
cleanup();
exit;


#################################################
# SUBS
#################################################
sub cleanup {
    `ps -efl | grep thruk_server | grep -v grep | awk '{ print \$4 }' | xargs -r kill >/dev/null 2>&1`;
    _safe_results();
}

#################################################
sub _safe_results {
    return unless $results;
    if(scalar keys %{$results}) {
        open(my $fh, '>', $results_file) or die("couldn't write results $results_file: $!");
        print $fh JSON::XS::encode_json($results);
        close($fh);
    }
    return;
}

#################################################
sub test_page {
    my($name, $url) = @_;
    our $currenttag;
    sleep $DELAY;
    my $cmd      = "ab -l -c $CONCURRENCY -n $REQUESTS $url 2>&1";
    my $pageres  = `$cmd`;
    my($page)    = $pageres =~ m/\QRequests per second:\E\s+([\d\.]+)/mx;
    my($pageerr) = $pageres =~ m/\QNon-2xx responses:\E|\QFailed requests:\E\s+([\d\.]+)/mx;
    if($pageerr && $pageerr >= 5) {
        printf "errored           | ";
        if($currenttag !~ m/^v/mx) {
            printf(STDERR "\n**********\n%s\n\ncmd: %s\n**********\n", $pageres, $cmd);
            exit;
        }
    } else {
        printf("%6s #/sec    | ", $page);
    }
    our $cur_pages;
    $cur_pages->{$name} = $page;
    return;
}

#################################################
sub switch_tag {
    my($tag) = @_;
    die("no tag") unless $tag;
    my $git = `git checkout -q $tag 2>&1`;
    if($git =~ /error:/) {
        printf("\n| %s", $git);
        exit;
    }
    `git log -1 2>&1`; # result in wrong startup times otherwise
    `git describe --tag --exact-match 2>&1`; # result in wrong startup times otherwise
    `git branch --no-color 2>&1`; # result in wrong startup times otherwise
    `rm -rf tmp/ttc_*`;
}

#################################################
sub test_tag {
    my($tag) = @_;
    our $currenttag = $tag;
    printf("| %-11s | ", substr($tag,0,11));
    switch_tag($tag);

    my $time = time();
    if($tag =~ /^v/mx) {
        chomp($time = `git log -1 --format=%ct $tag`);
    }

    # warmup, start twice to get more accurate startup times
    my $pid = _start_server();
    kill('TERM', $pid);
    sleep(3);

    my $t0 = [gettimeofday];
    $pid   = _start_server();
    my $elapsed = tv_interval($t0);
    printf("% 5.2fs  | ", $elapsed);

    # time for first request
    my $t1 = [gettimeofday];
    `ab -c 1 -n 1 "$BASEURL/cgi-bin/tac.cgi" > /dev/null 2>&1`;
    my $rc = $?;
    my $first_req = tv_interval($t0);
    printf("% 6.2fs | ", ($rc == 0 ? $first_req : 'Err'));


    # warm up
    `ab -c $CONCURRENCY -n 10 "$BASEURL/cgi-bin/tac.cgi" > /dev/null 2>&1`;

    our $cur_pages = {};
    test_page('main',   "$BASEURL/changes.html");
    test_page('tac',    "$BASEURL/cgi-bin/tac.cgi");
    test_page('status', "$BASEURL/cgi-bin/status.cgi");
    chomp(my $mem  = `cat /proc/$pid/status | grep VmRSS:  | awk '{print \$2}'`);
    test_page('json',   "$BASEURL/cgi-bin/status.cgi?style=hostdetail&hostgroup=all&view_mode=json");
    test_page('bp',     "$BASEURL/cgi-bin/bp.cgi");
    chomp(my $max  = `cat /proc/$pid/status | grep VmPeak: | awk '{print \$2}'`);
    chomp(my $load = `cat /proc/loadavg | awk '{ print \$1 }'`);

    kill('TERM', $pid);
    printf(" %3d MB (max. %4dMB) | %5s |\n", $mem/1000, $max/1000, $load);
    $results->{$time} = {
        time        => $time,
        tag         => $tag,
        startup     => $elapsed,
        first_req   => $first_req,
        load        => $load,
        mem         => $mem,
        max_mem     => $max,
        pages       => $cur_pages,
    };
    _safe_results();
    return;
}

#################################################
sub _start_server {
    chomp(my $pid = `./script/thruk_server.pl >/dev/null 2>&1 & echo \$!`);
    while(`lsof -i:$BASEPORT | grep -c LISTEN` != 1) {
        sleep(0.05);
        -d '/proc/'.$pid || die("failed to start!\n");
    }
    return($pid);
}