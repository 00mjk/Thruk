[% statusmap_header = BLOCK %]
  <link type="text/css" href="/thruk/plugins/statusmap/Treemap.css" rel="stylesheet" />
  <script language="javascript" type="text/javascript" src="/thruk/plugins/statusmap/jit-yc.js"></script>
[% END %]
[% PROCESS _header.tt extra_header => statusmap_header %]

<form method="get" action="statusmap.cgi">
<table border="0" width="100%" cellspacing="0" cellpadding="0" id="top_pane"[% IF hidetop == 1 %]style="visibility:hidden; display:none;"[% END %]>
  <tr>
    <td align="left" valign="top" width="33%">
      [% PROCESS _infobox.tt %]
    </td>
    <td align="center" valign="top" width="33%">
      <div align="center" class='dataTitle'>Statusmap For All Hosts</div><br>
    </td>
    <td align="right" valign="top" width="33%">
      <table border="0" cellspacing=2 cellpadding=2 class='optBox'>
        <tr>
          <td align="left" class='optBoxItem'>Map Layout:</td>
          <td align="left" class='optBoxItem'>Group By:</td>
        </tr>
        <tr>
          <td align="left" class='optBoxItem'>
            <select name='type'>
              <option value="1"[% IF type == 1 %] selected[% END %]>Table Layout</option>
              <option value="2"[% IF type == 2 %] selected[% END %]>Circular Layout</option>
            </select>
          </td>
          <td align="left" class='optBoxItem'>
            <select name='groupby'>
              <option value="1"[% IF groupby == 1 %] selected[% END %]>Parent</option>
              <option value="2"[% IF groupby == 2 %] selected[% END %]>IP Address</option>
            </select>
          </td>
        </tr>
        <tr>
          <td align="left" colspan="2" class='optBoxItem'>Detail Level:</td>
        </tr>
        <tr>
          <td align="left" colspan="2" class='optBoxItem'>
            <select name='level'>
              <option value="1"[% IF level == 1 %] selected[% END %]>1</option>
              <option value="2"[% IF level == 2 %] selected[% END %]>2</option>
              <option value="3"[% IF level == 3 %] selected[% END %]>3</option>
              <option value="4"[% IF level == 4 %] selected[% END %]>4</option>
              <option value="5"[% IF level == 5 %] selected[% END %]>5</option>
              <option value="6"[% IF level == 6 %] selected[% END %]>6</option>
            </select>
          </td>
        </tr>
        <tr>
          <td align="left" valign="bottom" class='optBoxItem'>
          </td>
          <td align="right" class='optBoxItem'>
            <input type='hidden' name='hidetop' id='hidetop' value='[% hidetop %]'>
            <input type='submit' value='Update'>
          </td>
        </tr>
      </table>
      [% IF show_context_help %]
      <br><a href='/thruk/docs/statusmap' target='cxhlp' onclick='javascript:window.open(this.href,"cxhlp","width=550,height=600,toolbar=0,location=0,status=0,resizable=1,scrollbars=1");return true'><img src='/thruk/themes/[% theme %]/images/contexthelp1.gif' width="30" height="29" border="0" alt='Display context-sensitive help for this screen' title='Display context-sensitive help for this screen'></a>
      [% END %]
    </td>
  </tr>
</table>
</form>
<br>

<div id="infovis"></div>
<div id="tooltip" class="tip" style="position: absolute; z-index: 13000; display: none;"></div>

<script type="text/javascript">
<!--
var a;
function addEvent(obj, type, fn) {
  if (obj.addEventListener)
    obj.addEventListener(type, fn, false);
  else
    obj.attachEvent('on' + type, fn);
};

function makeHTMLFromData(name, data){
  var html = '';

  if(data.status != undefined) {
    html += '<div class="tip-title">Host: ' + name + '<\/div>'
  } else {
    html += '<div class="tip-title">Network: ' + name + '<\/div>'
    html += '<div class="tip-text"><pre>';
    html += '<span class="' + ((data.state_up > 0) ? "hostUP" : "") +                   '"> Up: <\/span>          ' + data.state_up + '<br />';
    html += '<span class="' + ((data.state_down > 0) ? "hostDOWN" : "") +               '"> Down: <\/span>        ' + data.state_down + '<br />';
    html += '<span class="' + ((data.state_unreachable > 0) ? "hostUNREACHABLE" : "") + '"> Unreachable: <\/span> ' + data.state_unreachable + '<br />';
    html += '<span class="' + ((data.state_pending > 0) ? "hostPENDING" : "") +         '"> Pending: <\/span>     ' + data.state_pending + '<br />';
    html += '<\/div><\/pre>';
  }

  html += '<div class="tip-text"><pre>';
  if(data.status != undefined) {
    html += 'Alias:   ' + data.alias + '<br />';
    html += 'Address: ' + data.address + '<br />';
    html += 'Status:  <span class="' + data.class + '">&nbsp;' + data.status + '&nbsp;<\/span> ' + data.duration + '<br />';
    html += 'Output:  ' + data.plugin_output + '<br />';
  }
  html += '<\/div><\/pre>';
  return html;
};

function showTip(e, node) {

  tipOffsetX = 20;
  tipOffsetY = 20;

  tip = document.getElementById('tooltip');

  //Add mousemove event handler
  addEvent(e.target, 'mousemove', function(e, win){
      //get mouse position
      win = win  || window;
      e = e || win.event;
      var doc = win.document;
      doc = doc.html || doc.body;
      var page = {
          x: e.pageX || e.clientX + doc.scrollLeft,
          y: e.pageY || e.clientY + doc.scrollTop
      };
      tip.style.display = '';
      //get window dimensions
      win = {
          'height': document.body.clientHeight,
          'width': document.body.clientWidth
      };
      //get tooltip dimensions
      var obj = {
        'width': tip.offsetWidth,
        'height': tip.offsetHeight
      };
      //set tooltip position
      var style = tip.style, x = tipOffsetX, y = tipOffsetY;
      style.top = ((page.y + y + obj.height > win.height)?
          (page.y - obj.height - y) : page.y + y) + 'px';
      style.left = ((page.x + obj.width + x > win.width)?
          (page.x - obj.width - x) : page.x + x) + 'px';
  });

  addEvent(e.target, 'mouseout', function(e, win){
    tip.style.display = 'none';
  });


  tip.innerHTML = makeHTMLFromData(node.name, node.data);
}
var a;
function init(){
    //init data
    var json    = [% json %];
    var infovis = document.getElementById('infovis');
    var w = infovis.offsetWidth - 20, h = infovis.offsetHeight - infovis.offsetTop - 20;
    infovis.style.width = w + 'px';
    infovis.style.height = h + 'px';

[%# Table Layout #%]
[% IF type == '1' %]
    //init tm
//    alert(TreeUtil.loadSubtrees);
//    TreeUtil.loadSubtrees = function(tree, controller) {
//        var maxLevel = controller.request && controller.levelsToShow;
//alert(maxLevel);
//        var leaves = this.getLeaves(tree, maxLevel),
//        len = leaves.length,
//        selectedNode = {};
//        if(len == 0) controller.onComplete();
//        for(var i=0, counter=0; i<len; i++) {
//            var leaf = leaves[i], id = leaf.node.id;
//            selectedNode[id] = leaf.node;
//            controller.request(id, leaf.level, {
//                onComplete: function(nodeId, tree) {
//                    var ch = tree.children;
//                    selectedNode[nodeId].children = ch;
//                    if(++counter == len) {
//                        controller.onComplete();
//                    }
//                }
//            });
//        }
//    };


//     onRightClick: function() {
//        a = this;
//        this.out();
//        alert(this.shownTree.id);
//
//        var tree = json;
//        var subtree = TreeUtil.getSubtree(tree, this.shownTree.id);
//        TreeUtil.prune(subtree, 1);
//        //onComplete.onComplete(nodeId, subtree);
//        tm.loadJSON(subtree);
//
//        //var tree = json;
//        //var subtree = TreeUtil.getSubtree(tree, nodeId);
//        //TreeUtil.prune(subtree, 1);
//        //onComplete.onComplete(nodeId, subtree);
//     }
//    });
    var tm = new TM.Squarified({
        //The id of the treemap container
        rootId: 'infovis',
        //Set the max. depth to be shown for a subtree
        //levelsToShow: [% level %],
        levelsToShow: 2,

        // space between divs
        offset: 4,

        //Add click handlers for
        //zooming the Treemap in and out
        addLeftClickHandler: true,
        addRightClickHandler: true,

        //When hovering a node highlight the nodes
        //between the root node and the hovered node. This
        //is done by adding the 'in-path' CSS class to each node.
        selectPathOnHover: true,

        // add host class for the host nodes
        onCreateElement:  function(content, node, isLeaf, head, body) {
          if(isLeaf && node.data.class != undefined && head) {
            head.className = (head.className + " " + node.data.class);
          }
          head.onmouseover = function (e){showTip((e||window.event), node)};
        },
        request: function(nodeId, level, onComplete){
            var tree = json;
            var subtree = TreeUtil.getSubtree(tree, nodeId);
            TreeUtil.prune(subtree, 1);
            onComplete.onComplete(nodeId, subtree);
            //tm.loadTree('rootid');
        }
        //Remove all events for the element before destroying it.
        //onDestroyElement: function(content, tree, isLeaf, leaf){
        //    if(leaf.clearAttributes) leaf.clearAttributes();
        //}
    });
    tm.loadJSON(json);
    tm.loadTree('rootid');
[% END %]


[%# Circular Layout #%]
[% IF type == '2' %]

  // distance between circles
  var levelDistance = 100;

  //Create a new canvas instance.
  var canvas = new Canvas('mycanvas', {
      //Where to append the canvas widget
      'injectInto': 'infovis',
      'width': w,
      'height': h,

      //Optional: create a background canvas and plot
      //concentric circles in it.
      'backgroundCanvas': {
          'styles': {
              'strokeStyle': '#CCCCCC'
          },

          'impl': {
              'init': function(){},
              'plot': function(canvas, ctx){
                  var times = 6, d = levelDistance;
                  var pi2 = Math.PI * 2;
                  for (var i = 1; i <= times; i++) {
                      ctx.beginPath();
                      ctx.arc(0, 0, i * d, 0, pi2, true);
                      ctx.stroke();
                      ctx.closePath();
                  }
              }
          }
      }
  });

  var rgraph = new RGraph(canvas, {
      levelDistance: levelDistance,
      duration: 700,
      fps: 40,

      Node: { //Set Node and Edge colors.
          overridable: true,
      },
      Edge: {
          color: '#333333'
      },

      //Add the name of the node in the correponding label
      //and a click handler to move the graph.
      //This method is called once, on label creation.
      onCreateLabel: function(domElement, node){
          domElement.innerHTML = node.name;
          domElement.onclick = function(){
              rgraph.onClick(node.id);
          };
      },
      //Change some label dom properties.
      //This method is called each time a label is plotted.
      onPlaceLabel: function(domElement, node){
          var style = domElement.style;
          //style.visibility = 'visible';
          style.cursor = 'pointer';
          style.height = '';
          style.width  = '';

          if(node._depth <= 1) {
              style.fontSize = '0.9em';
              style.color    = '#000000';
          }
          else if(node._depth <= 3){
              style.fontSize = '0.8em';
              style.color    = '#494949';
          }else {
              style.fontSize = '0px';
              style.height   = '10px';
              style.width    = '10px';
              //style.visibility = 'hidden';
          }

          domElement.onmouseover = function (e){showTip((e||window.event), node)};

          var left = parseInt(style.left);
          var w = domElement.offsetWidth;
          style.left = (left - w / 2) + 'px';
      },
  });

  //load JSON data
  rgraph.loadJSON(json);
  //compute positions and make the first plot
  rgraph.refresh();

[% END %]

}

// show graph
init();
-->
</script>

[% PROCESS _footer.tt %]
