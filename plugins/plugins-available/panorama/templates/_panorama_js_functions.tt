/* send debug output to firebug console */
var debug = function(str) {}
if(thruk_debug_js != undefined && thruk_debug_js) {
    if(window.console != undefined) {
        /* overwrite debug function, so caller information is not replaced */
        try {
            debug = console.debug;
            debug('console debug log enabled');
        } catch(e) {
            debug = function(str) {}
        }
    }
}

/* uppercase first char */
function ucfirst(str) {
    var firstLetter = str.slice(0,1);
    return firstLetter.toUpperCase() + str.substring(1);
}

/* global Thruk Panorama Object */
var TP = {
    snap_x: 20,
    snap_y: 20,
    offset_y: 25,

    get_snap: function (x, y) {
        newx = Math.round(x/TP.snap_x) * TP.snap_x;
        newy = Math.round(y/TP.snap_y) * TP.snap_y + 5;
        if(newx < 0) { newx = 0; }
        if(newy < 0) { newy = 0; }
        if(newy < TP.offset_y) { newy = TP.offset_y; }
        return([newx, newy]);
    },

    add_pantab: function(id) {
        var tabpan = Ext.getCmp('tabpan');
        var size   = tabpan.items.length;
        var nextid = TP.getNextId("tabpan-tab", id);
        if(cp.state[nextid] == undefined) {
            TP.initialized = true;
        }
        /* add new tab panel */
        tabpan.add(new TP.Pantab({id: nextid})).show();

        /* move new-tab button at the end */
        tabpan.getTabBar().move(size-1, size);

        /* make tab title editable */
        [% UNLESS readonly %]
        var tabhead = tabpan.getTabBar().items.getAt(size-1);
        if(tabhead.rendered == false) {
            tabhead.addListener('afterrender', function(This, eOpts) {
                TP.addDblClickRename(This.getEl(), tabhead, nextid);
            });
        } else {
            TP.addDblClickRename(tabhead.getEl(), tabhead, nextid);
        }
        [% END %]

        /* save tabs state */
        Ext.getCmp('tabpan').saveState();

        /* return false to prevent newtab button being activated */
        return false;
    },

    /* clone config from given panel which can be used to create a clone */
    clone_panel_config: function(panel) {
        var config = TP.clone(panel.getState());
        delete config.id;
        return(config);
    },

    /* add given panlet */
    add_panlet: function(config, smartPlacement) {
        [%+ IF readonly +%]
        if(TP.initialized) {
            return false;
        }
        [%+ END +%]
        if(config == undefined) {
            throw new Error("TP.add_panlet(): no config! (caller: " + (TP.add_panlet.caller ? TP.add_panlet.caller : 'unknown') + ")");
        }
        if(config.conf == undefined) {
            config.conf = {};
        }
        config.conf.id = TP.getNextId("panlet", config.id);
        var state = cp.state;
        if(state[config.conf.id] != undefined
           && state[config.conf.id].xdata != undefined
           && state[config.conf.id].xdata.cls != undefined) {
            config.type = state[config.conf.id].xdata.cls;
        }
        if(config.type == undefined) {
            throw new Error("TP.add_panlet(): no type! (caller: " + (TP.add_panlet.caller ? TP.add_panlet.caller : 'unknown') + ")");
        }
        var pan = Ext.getCmp('tabpan');
        var tb;

        if(config.tb) {
            tb                   = config.tb;
            config.conf.autoShow = config.autoshow;
        } else {
            config.conf.autoShow = true;
            tb  = pan.getActiveTab();
            if(!tb) {
                tb = pan.setActiveTab(0);
            }
        }
        if(!tb) {
            throw new Error("TP.add_panlet(): no active tab! (caller: " + (TP.add_panlet.caller ? TP.add_panlet.caller : 'unknown') + ")");
        }
        // fake state (probably cloned)
        if(config.state) {
            cp.set(config.conf.id, config.state);
        }
        var win = Ext.create(config.type, config.conf);
        win.panel_id = tb.id;
        if(smartPlacement == undefined || smartPlacement == true) {
            pan.setActiveTab(tb); /* otherwise panel won't be rendered and panel size is 0 */
            if(config.conf.pos) {
                win.setPosition(config.conf.pos[0], config.conf.pos[1]);
            } else {
                TP.fitWindowPlacement(tb, win);
            }
        }
        if(!config.skip_state) {
            tb.window_ids.push(win.id);
            tb.saveState();
        }
        // update initial panlet counter
        var tmp = Ext.dom.Query.select('.x-mask-loading DIV');
        if(tmp.length > 0) {
            tmp[0].innerHTML = "loading panel "+TP.cur_panels+'/'+TP.num_panels+"...";
            TP.cur_panels++;
        }
        return true;
    },

    /* choose position handler */
    add_panlet_handler: function(evt, element, args) {
        var tb = args[0], config = args[1], offsetX = args[2], offsetY = args[3];
        tb.getEl().un('click', TP.add_panlet_handler, this, args); // remove event handler again
        if(config.conf == undefined) { config.conf = {}; }
        config.conf.pos = [evt.getX()+offsetX, evt.getY()+offsetY];
        tb.getEl().dom.style.cursor = '';
        TP.add_panlet(config);
    },

    /* add panel, but let the user choose position */
    add_panlet_delayed: function(config, offsetX, offsetY) {
        var tb;
        var pan = Ext.getCmp('tabpan');
        if(config.tb) {
            tb = config.tb;
        } else {
            tb = pan.getActiveTab();
            if(!tb) {
                tb = pan.setActiveTab(0);
            }
        }
        if(!tb) {
            throw new Error("TP.add_panlet(): no active tab! (caller: " + (TP.add_panlet.caller ? TP.add_panlet.caller : 'unknown') + ")");
        }
        tb.getEl().dom.style.cursor = 'crosshair';
        tb.getEl().on('click', TP.add_panlet_handler, tb, [tb, config, offsetX, offsetY]);
    },

    /* return next unused id */
    getNextId: function(prefix, id) {
        if(id != undefined) {
            return id;
        }
        var nr = 1;
        while(Ext.getCmp(prefix + "_" + nr) != undefined) {
            nr++;
        }
        return(prefix + "_" + nr);
    },

    /* remove item from an array */
    removeFromList: function(list, item) {
        var newlist = [];
        for(var key in list) {
            if(list[key] != item) {
                newlist.push(list[key]);
            }
        }
        return(newlist);
    },

    /* show about window */
    aboutWindow: function() {
        new Ext.window.Window({
            autoShow:   true,
            modal:      true,
            title:      'About Thruks Panorama',
            buttonAlign: 'center',
            items: [{
                html: 'Thruk Panorama<br><br>Copyright 2012 Sven Nierlein, sven@consol.de<br>License: GPL v3<br>Version: [% version %][% IF branch %]~[% branch %][% END %][% IF c.config.extra_version %] <font size="-3">([% c.config.extra_version %])<\/font>[% END %]'
            }],
            fbar: [{
                text:'OK',
                handler: function() { this.up('window').destroy() }
            }]
        });
    },

    /* get box coordinates for given object */
    getBox: function(obj) {
        var pos  = obj.getPosition();
        var size = obj.getSize();
        var box = {
            tl: { x:pos[0], y:pos[1] },
            tr: { x:pos[0]+size.width, y:pos[1] },
            bl: { x:pos[0], y:pos[1]+size.height },
            br: { x:pos[0]+size.width, y:pos[1]+size.height }
        };
        return box;
    },

    /* smart placement for new windows */
    fitWindowPlacement: function(tab, win) {
        var box     = TP.getBox(win);
        var tabsize = tab.getSize();

        /* get list of boxes */
        var boxes = [];
        var tabpan = Ext.getCmp('tabpan');
        tabpan.items.each(function(panel) {
            if(panel.window_ids) {
                for(var nr=0; nr<panel.window_ids.length; nr++) {
                    var id = panel.window_ids[nr];
                    var w  = Ext.getCmp(id);
                    if(id != win.id && (panel.id == win.panel_id || w.xdata.pinned == true )) {
                        boxes.push(TP.getBox(w));
                    }
                };
            }
        });

        /* get first place which fits */
        var x = 0;
        var y = TP.offset_y;
        while(TP.boxesOverlap(x, y, box, boxes)) {
            x = x + TP.snap_x;
            if(x+box.tr.x > tabsize.width) {
                x = 0;
                y = y + TP.snap_y;
            }
            if(y+box.bl.y > tabsize.height) {
                /* nothing matched, just placed at 0,0 */
                x = 0;
                y = TP.offset_y;
                break;
            }
        }
        win.setPosition(x, y);
    },
    /* returns true if any box ovelap */
    boxesOverlap: function(x, y, box, boxes) {
        var tmp_box = {
            tl: { x:x, y:y },
            tr: { x:x+(box.tr.x-box.tl.x), y:y },
            bl: { x:x, y:y+(box.br.y-box.tr.y) },
            br: { x:x+(box.tr.x-box.tl.x), y:y+(box.br.y-box.tr.y) }
        };

        for(var nr=0; nr<boxes.length; nr++) {
            var b = boxes[nr];
            /* check if these boxes overlap */
            if(TP.boxOverlap(tmp_box, b)) { return true; }
            if(TP.boxOverlap(b, tmp_box)) { return true; }
        }
        return false;
    },
    /* returns true if both boxes ovelap */
    boxOverlap: function(b1, b2) {
        if(b1.tl.x >= b2.tl.x && b1.tl.x < b2.tr.x && b1.tl.y >= b2.tl.y && b1.tl.y <  b2.bl.y) { return true; }
        if(b1.tr.x >  b2.tl.x && b1.tr.x < b2.tr.x && b1.tr.y >= b2.tl.y && b1.tr.y <  b2.bl.y) { return true; }
        if(b1.bl.x >= b2.tl.x && b1.bl.x < b2.tr.x && b1.bl.y >  b2.tl.y && b1.bl.y <= b2.bl.y) { return true; }
        if(b1.br.x >  b2.tl.x && b1.br.x < b2.tr.x && b1.br.y >  b2.tl.y && b1.br.y <= b2.bl.y) { return true; }
        return false;
    },
    /* hide element in given form */
    hideFormElements: function(form, list) {
        form.getFields().each(function(f, i) {
            for(var nr=0; nr<list.length; nr++) {
                if(f.name == list[nr]) { f.hide() }
            }
        });
    },
    /* refresh all site specific panlets */
    refreshAllSitePanel: function() {
        var panels = TP.getAllPanel();
        for(var nr=0; nr<panels.length; nr++) {
            var p = panels[nr];
            if(p.reloadOnSiteChanges != undefined && p.reloadOnSiteChanges == true && p.isVisible()) {
                p.refreshHandler();
            }
        }
    },
    refreshAllPanel: function() {
        var panels = TP.getAllPanel();
        for(var nr=0; nr<panels.length; nr++) {
            panels[nr].refreshHandler();
        }
    },
    /* return all panlets */
    getAllPanel: function() {
        var panels = [];
        var tabpan = Ext.getCmp('tabpan');
        tabpan.items.each(function(panel) {
            if(panel.window_ids) {
                for(var nr=0; nr<panel.window_ids.length; nr++) {
                    var id = panel.window_ids[nr];
                    var p  = Ext.getCmp(id);
                    if(p) { // can be undefined unless already rendered
                        panels.push(p);
                    }
                }
            }
        });
        return panels;
    },
    /* set form values from data hash */
    applyFormValues: function(form, data) {
        var fields = form.getFields();
        TP.setRefreshText(data, 'refresh', 'refresh_txt');
        fields.each(function(f) {
            var v = data[f.getName()];
            if(f.xtype == 'combobox' && f.multiSelect == true) {
                f.originalValue = v;
                f.value = v;
                f.setValue(v);
            }
            else if(f.inputType == 'checkbox') {
                f.setValue(v);
                f.originalValue = v;
            } else {
                f.originalValue = [ v ];
                f.setValue(v);
                f.value = v;
            }
        });

        /* checkbox groups are different */
        var items = form.getFields().items;
        for(var i=0; i<items.length; i++) {
            var f = items[i];
            if(f.xtype == 'checkboxgroup') {
                f.removeAll();
                for(var key in initial_backends) {
                    var checked = false;
                    if(Ext.Array.contains(data.backends, key)) { checked = true; }
                    f.add({ boxLabel: initial_backends[key].name, name: 'backends', inputValue: key, checked: checked });
                }
            }
        };

        delete data['refresh_txt'];
        return true;
    },
    /* store form result in data hash  */
    storeFormToData: function(form, data) {
        var values = form.getFieldValues();
        /* save values to xdata store */
        for(var key in values) {
            data[key] = values[key];
        };
        /* checkboxgroups are different */
        var items = form.getFields().items;
        for(var i=0; i<items.length; i++) {
            var f = items[i];
            if(f.xtype == 'checkboxgroup') {
                var result = {};
                var checked = f.getChecked();
                for(var nr=0; nr<checked.length; nr++) {
                    c = checked[nr];
                    if(result[c.name] == undefined) {
                        result[c.name] = [];
                    }
                    result[c.name].push(c.inputValue);
                }
                for(var nr=0; nr<result.length; nr++) {
                    data[nr] = result[nr];
                }
            }
        }
        return data;
    },
    /* clone an object */
    clone: function(o) {
        return(Ext.JSON.decode(Ext.JSON.encode(o)));
    },
    /* convert backends into array usable by data store */
    getBackendsArray: function(backends) {
        var data = [];
        for(var key in backends) {
            data.push([key, backends[key].name]);
        }
        return data;
    },
    /* default refresh handler */
    defaultSiteRefreshHandler: function(panel) {
        if(panel.xdata.url != '' && panel.xdata.refresh != -2) { // -2 means temporarily disabled
            var url = panel.xdata.url;
            if(panel.loader.baseParams == undefined) {
                panel.loader.baseParams = {};
            }
            var baseParams = Ext.merge(panel.loader.baseParams, panel.xdata);
            delete baseParams['gridstate']; // not needed
            panel.loader.load({url:url, baseParams: baseParams});
        }
    },
    startAllPanelRefresh: function() {
        TP.stopAllPanelRefresh();
        var panels = TP.getAllPanel();
        // spread panel reload
        if(panels.length > 30) {
            var delay    = 0;
            var interval = 60 / panels.length;
            for(var nr=0; nr<panels.length; nr++) {
                if(panels[nr].startInterval) {
                    window.setTimeout(Ext.bind(panels[nr].startInterval, panels[nr], []), delay);
                    delay = delay + Math.round(interval*1000);
                }
            }
        } else {
            // no delay required
            for(var nr=0; nr<panels.length; nr++) {
                if(panels[nr].startInterval) {
                    panels[nr].startInterval();
                }
            }
        }
        TP.initialized = true;

        var tabpan    = Ext.getCmp('tabpan');
        var activeTab = tabpan.getActiveTab();
        if(!activeTab) {
            debug("forced setting activeTab");
            activeTab = tabpan.setActiveTab(0);
        }

        // ensure panels from the active tab are displayed
        if(TP.initial_active_tab != activeTab.getStateId()) {
            debug("active tab changed...");
            for(var nr=0; nr<activeTab.window_ids.length; nr++) {
                var panlet = Ext.getCmp(activeTab.window_ids[nr]);
                if(panlet) { // may not yet exists due to delayed rendering
                    try {    // so allow it to fail
                        panlet.show(false);
                    } catch(e) { debug(e) }
                }
            }
        }
        if(tabpan.xdata.refresh > 0) {
            TP.timeouts['global'] = window.setInterval(TP.updateAllIcons, tabpan.xdata.refresh * 1000);
        }
        if(TP.initMask) { TP.initMask.destroy() }
    },
    stopAllPanelRefresh: function() {
        var panels = TP.getAllPanel();
        for(var nr=0; nr<panels.length; nr++) {
            if(panels[nr].stopInterval) {
                panels[nr].stopInterval();
            }
        }
        window.clearInterval(TP.timeouts['global']);
    },
    /* convert time frame into seconds */
    timeframe2seconds: function(timedef) {
        var res  = timedef.match(/^(\d+)(\w{1})/);
        if(res && res.length == 1) {
            return 3600;
        }
        var nr    = res[1];
        var unit  = res[2];
        if(unit == 'm') { return nr * 60; }     // minutes
        if(unit == 'h') { return nr * 3600; }   // hours
        if(unit == 'd') { return nr * 86400; }  // days
        if(unit == 'w') { return nr * 604800; } // weeks
        return 3600;
    },
    /* import tabs from string */
    importAllTabs: function(data) {
        try {
            data = cp.decodeValue(decode64(data));
        }
        catch(e) {
            Ext.MessageBox.alert('Failed', 'Import Failed!');
            return;
        }
        if(data == undefined || data == '') { data = {} }

        // stop everything
        this.stopRotatingTabs();
        this.stopAllPanelRefresh();

        cp.clearAll();
        cp.loadData(data);
        window.setTimeout("window.location.reload()", 1000);
    },
    /* eval response data */
    getResponse: function(panlet, response, no_json) {
        var refresh = {setType: Ext.emptyFn };
        if(panlet != undefined) {
            refresh = panlet.getTool('refresh') || panlet.getTool('broken');
        }
        if(response.status == 200) {
            var data;
            if(no_json) {
                return(response.responseText);
            }
            try {
                data = eval("("+response.responseText+")");
            } catch(e) {
                if(refresh.setType) { refresh.setType('broken') }
                debug(e);
                return data;
            }
            if(refresh.setType) { refresh.setType('refresh') }
            /* extract pi details */
            if(data.pi_detail != undefined) {
                for(var key in data.pi_detail) {
                    initial_backends[key].state         = 0;
                    initial_backends[key].program_start = 0;
                    try {
                        initial_backends[key].state         = data.pi_detail[key]['state'];
                        initial_backends[key].program_start = data.pi_detail[key]['program_start'];
                    } catch(e) {
                        debug(e);
                    }
                }
            }
            /* contains a message? */
            var msg = Ext.util.Cookies.get('thruk_message');
            if(msg) {
                TP.Msg.msg(msg);
                // clear message
                Ext.util.Cookies.clear('thruk_message', '[% cookie_path %]');
            }
            if(data.errors) {
                for(var nr=0; nr<data.errors.length; nr++) {
                    TP.Msg.msg("fail_message~~"+data.errors[nr].message);
                }
            }
            return data;
        }
        if(response.status == 0) {
            // ok too
            return false;
        }
        debug("ERROR: " + response.status + ' (' + response.request.options.url + ')');
        debug(response);
        if(refresh.setType) { refresh.setType('broken') }
        return false;
    },
    /* sets text for refresh slider */
    setRefreshText: function(data, slider, text) {
        data[text] = TP.sliderValue2Txt(data[slider]);
    },
    /* convert value to human text */
    sliderValue2Txt: function(v) {
        if(v == -1) { return 'default'; }
        if(v ==  0) { return 'off'; }
        return v+'s';
    },
    /* start tab rotation interval */
    startRotatingTabs: function() {
        var tabpan = Ext.getCmp('tabpan');
        this.stopRotatingTabs();
        if(tabpan.xdata.rotate_tabs > 0) {
            debug("starting tab rotation every " + tabpan.xdata.rotate_tabs + "seconds");
            tabpan.interval_rotatetabs = window.setInterval(TP.rotateTabs, tabpan.xdata.rotate_tabs * 1000);
        }
    },
    /* start server time */
    startServerTime: function() {
        var tabpan = Ext.getCmp('tabpan');
        window.clearInterval(tabpan.interval_servertime);
        var label = Ext.getCmp('server_time');
        if(!tabpan.xdata.server_time) {
            label.hide();
            return;
        }
        label.show();
        tabpan.interval_servertime = window.setInterval(TP.updateServerTime, 1000);
    },
    /* update server time */
    updateServerTime: function() {
        var label  = Ext.getCmp('server_time');
        var client = new Date();
        var time   = Math.floor((client.getTime() - delta_time) / 1000);
        var date   = TP.date_format(time, 'H:i');
        label.update(date);
    },
    /* stop tab rotation interval */
    stopRotatingTabs: function() {
        var tabpan = Ext.getCmp('tabpan');
        window.clearInterval(tabpan.interval_rotatetabs);
    },
    /* rotate tabs once */
    rotateTabs: function() {
        var tabpan = Ext.getCmp('tabpan');
        var state  = tabpan.getState();
        var at     = state.activeTab;
        // find next tab
        var found = false;
        var next  = undefined;
        tabpan.items.each(function(tab) {
            if(found == true) {
                next = tab.id;
                return false;
            }
            if(tab.id == at) {
                found = true;
            }
        });
        if(next == undefined || !tabpan.setActiveTab(next)) {
            tabpan.setActiveTab(1);
        }
    },
    addDblClickRename: function(el, item, id) {
        el.on("dblclick", function() {
            TP.tabSettingsWindow();
        });
    },
    /* sum list elements */
    arraySum: function(list) {
        var l=list.length, i=0, n=0;
        while(i<l) { n += list[i++]} ;
        return n;
    },
    addFormFilter: function(This, type) {
        This.obj_filter = new TP.formFilter({
            fieldLabel:     'Filter',
            name:           'filter',
            ftype:          type
        });
        This.down('form').add(This.obj_filter);
    },
    /* convert number to binary list */
    dec2bin: function(dec) {
        var potencies = new Array();
        var binary = [];
        for (var i = 0; i > -1; i++) {
            var potency = Math.pow(2, i);
            if (potency > dec) { break; }
            potencies[i] = potency;
        }

        potencies.reverse();

        for (var j = 0; j < potencies.length; j++) {
            var position = potencies[j];
            var zeroOne = parseInt(dec / position);
            if(zeroOne) {
                binary.push(position);
            }
            dec -= potencies[j] * zeroOne;
        }
        return binary;
    },
    /* update an array store with new data */
    updateArrayStore: function(store, data) {
        if(!store) { return; }
        store.suspendEvents(false);
        store.removeAll();
        var num = data.length-1;
        for(var x=0;x<num;x++) {
            store.loadRawData([[data[x]]], true);
        }
        store.resumeEvents();
        // add last one to trigger some events
        store.loadRawData([[data[x]]], true);
    },
    /* return location object for url */
    getLocationObject: function(url) {
        var a  = document.createElement('a');
        a.href = url;
        return(a);
    },
    /* compare same origin policy */
    isSameOrigin: function(l1, l2) {
        if(l1.protocol != l2.protocol) {
            return false;
        }
        if(l1.host != l2.host) {
            return false;
        }
        return true;
    },
    /* called on body unload */
    unload: function() {
        try {
            // try saving state
            cp.saveChanges(false);
        }
        catch(e) {}
    },
    deleteDowntime: function(id, panelId, type) {
        var panel = Ext.getCmp(panelId);
        var fields = [{
            fieldLabel: '',
            xtype:      'displayfield',
            value:      'no options needed',
            name:       'display',
            width:      240
        }, {
            xtype: 'hidden', name: 'down_id', value: id
        }];
        var menuCfg = TP.ext_menu_command('Remove', (type == 'host' ? 78 : 79), fields);
        var menu = new Ext.menu.Menu(menuCfg);
        panel.add(menu);
        menu.show();
    },
    objectSearchItem: function(type, name) {
        var handler = function() {
            if(searchStore.search_type != type) {
                searchStore.search_type = type;
                if(type == 'service') {
                    searchStore.getProxy().extraParams.host = this.up('form').getForm().getFieldValues().host;
                } else {
                    delete searchStore.getProxy().extraParams.host;
                }
                searchStore.load();
            }
        };
        return({
            name:           type,
            fieldLabel:     name,
            xtype:          'combobox',
            queryMode:      'remote',
            store:          searchStore,
            triggerAction:  'all',
            pageSize:       true,
            selectOnFocus:  true,
            typeAhead:      true,
            minChars:       0,
            listeners: {
                'expand': handler,
                'change': handler,
                'keyup':  handler
            }
        });
    },
    removeWindowFromPanels: function(win_id) {
        /* remove panel reference */
        var tabpan = Ext.getCmp('tabpan');
        tabpan.items.each(function(panel) {
            if(panel.window_ids) {
                panel.window_ids = TP.removeFromList(panel.window_ids, win_id);
                panel.saveState();
            }
        });
    },
    updateAllIcons: function(id) {
        var panels = TP.getAllPanel();
        var req    = { hosts: {}, hostgroups: {}, services: {}, servicegroups: {}};
        var ref    = { hosts: {}, hostgroups: {}, services: {}, servicegroups: {}, sites: {}};
        for(var nr=0; nr<panels.length; nr++) {
            var p = panels[nr];
            if(id && p.id != id) { continue; }
            if(p.xdata && p.xdata.general) {
                if(p.xdata.general.service && p.xdata.general.host) {
                    if(req.services[p.xdata.general.host] == undefined) {
                        req.services[p.xdata.general.host] = {};
                        ref.services[p.xdata.general.host] = {};
                    }
                    if(ref.services[p.xdata.general.host][p.xdata.general.service] == undefined) {
                        ref.services[p.xdata.general.host][p.xdata.general.service] = [];
                    }
                    req.services[p.xdata.general.host][p.xdata.general.service] = 1;
                    ref.services[p.xdata.general.host][p.xdata.general.service].push(p);
                }
                else if(p.xdata.general.host) {
                    if(ref.hosts[p.xdata.general.host] == undefined) { ref.hosts[p.xdata.general.host] = []; }
                    req.hosts[p.xdata.general.host] = 1;
                    ref.hosts[p.xdata.general.host].push(p);
                }
                else if(p.xdata.general.hostgroup) {
                    if(ref.hostgroups[p.xdata.general.hostgroup] == undefined) { ref.hostgroups[p.xdata.general.hostgroup] = []; }
                    req.hostgroups[p.xdata.general.hostgroup] = 1;
                    ref.hostgroups[p.xdata.general.hostgroup].push(p);
                }
                else if(p.xdata.general.servicegroup) {
                    if(ref.servicegroups[p.xdata.general.servicegroup] == undefined) { ref.servicegroups[p.xdata.general.servicegroup] = []; }
                    req.servicegroups[p.xdata.general.servicegroup] = 1;
                    ref.servicegroups[p.xdata.general.servicegroup].push(p);
                }
                else if(p.xdata.general.site) {
                    if(ref.sites[p.xdata.general.site] == undefined) { ref.sites[p.xdata.general.site] = []; }
                    ref.sites[p.xdata.general.site].push(p);
                }
            }
        };
        Ext.Ajax.request({
            url: 'panorama.cgi?task=status',
            method: 'POST',
            params: { types: Ext.JSON.encode(req) },
            callback: function(options, success, response) {
                if(!success) {
                    // not yet handled:
                    // add global error indicator
                } else {
                    var data = TP.getResponse(undefined, response);
                    data = data.data;
                    if(data.hosts) {
                        for(var x=0; x<data.hosts.length; x++) {
                            var name  = data.hosts[x]['name'];
                            var state = data.hosts[x]['state'];
                            for(var y=0; y<ref.hosts[name].length; y++) {
                                ref.hosts[name][y].host = data.hosts[x];
                                ref.hosts[name][y].refreshHandler(state);
                            }
                        }
                    }
                    if(data.hostgroups) {
                        for(var x=0; x<data.hostgroups.length; x++) {
                            var name  = data.hostgroups[x]['name'];
                            var state = data.hostgroups[x]['state'];
                            for(var y=0; y<ref.hostgroups[name].length; y++) {
                                ref.hostgroups[name][y].hostgroup = data.hostgroups[x];
                                ref.hostgroups[name][y].refreshHandler();
                            }
                        }
                    }
                    if(data.servicegroups) {
                        for(var x=0; x<data.servicegroups.length; x++) {
                            var name  = data.servicegroups[x]['name'];
                            var state = data.servicegroups[x]['state'];
                            for(var y=0; y<ref.servicegroups[name].length; y++) {
                                ref.servicegroups[name][y].servicegroup = data.servicegroups[x];
                                ref.servicegroups[name][y].refreshHandler();
                            }
                        }
                    }
                    if(data.services) {
                        for(var x=0; x<data.services.length; x++) {
                            var hst   = data.services[x]['host_name'];
                            var svc   = data.services[x]['description'];
                            var state = data.services[x]['state'];
                            for(var y=0; y<ref.services[hst][svc].length; y++) {
                                ref.services[hst][svc][y].service = data.services[x];
                                ref.services[hst][svc][y].refreshHandler(state);
                            }
                        }
                    }
                    if(data.backends) {
                        for(var key in data.backends) {
                            var name = data.backends[key].name;
                            if(ref.sites[name]) {
                                for(var x=0; x<ref.sites[name].length; x++) {
                                    ref.sites[name][x].site = data.backends[key];
                                    ref.sites[name][x].refreshHandler();
                                }
                            }
                        }
                    }
                }
            }
        });
    },
    /* let this element flicker and make it a little bit bigger */
    flickerImg: function(id) {
        var el     = Ext.ComponentManager.get(id);
        var size   = el.getSize();
        var factor = 1.2;
        var origLeft = el.getEl().dom.style.left;
        var origTop  = el.getEl().dom.style.top;
        el.getEl().dom.style.left = Number(el.getEl().dom.style.left.replace(/px$/, '')) - (size.width*(factor*0.25))+"px";
        el.getEl().dom.style.top  = Number(el.getEl().dom.style.top.replace(/px$/, ''))  - (size.height*(factor*0.25))+"px";
        el.setSize({width: size.width*factor, height: size.height*factor});
        el.animate({ to: { opacity: 0   } })
          .animate({ to: { opacity: 100 } })
          .animate({ to: { opacity: 0   } })
          .animate({ to: { opacity: 100 } })
          .animate({ to: { opacity: 0   } })
          .animate({ to: { opacity: 100 } })
          .animate({ to: { opacity: 0   } })
          .animate({ to: { opacity: 100 } })
          .animate({ to: { opacity: 0   } })
          .animate({ to: { opacity: 100 } })
        el.syncShadow();
        window.setTimeout(function() {
            el.setSize({width: size.width, height: size.height});
            el.getEl().dom.style.left = origLeft;
            el.getEl().dom.style.top  = origTop;
            el.syncShadow();
        }, 2500);
    }
}
